const std = @import("std");
const zcli = @import("zcli");
const discovery = @import("discovery");

const Coordinator = discovery.Coordinator;
const AggregatedEnvVar = discovery.AggregatedEnvVar;
const Warning = discovery.Warning;
const ConfigType = discovery.ConfigType;
const Confidence = discovery.Confidence;

pub const meta = .{
    .description = "Discover environment variables used in source code",
    .examples = &.{
        "configflow discover",
        "configflow discover --path ./src",
        "configflow discover --verbose",
        "configflow discover --format json",
        "configflow discover --generate-env-example",
        "configflow discover --generate-env-example .env.template",
    },
    .options = .{
        .path = .{ .description = "Path to scan (default: current directory)", .short = 'p' },
        .verbose = .{ .description = "Show detailed information", .short = 'v' },
        .quiet = .{ .description = "Disable progress indicators", .short = 'q' },
        .format = .{ .description = "Output format: text (default) or json", .short = 'f' },
        .@"generate-env-example" = .{ .description = "Generate .env.example file (optional: specify path)", .short = 'g' },
    },
};

pub const Args = struct {};

pub const Options = struct {
    path: ?[]const u8 = null,
    verbose: bool = false,
    quiet: bool = false,
    format: ?[]const u8 = null,
    @"generate-env-example": ?[]const u8 = null,
};

pub fn execute(_: Args, options: Options, context: *zcli.Context) !void {
    const allocator = context.allocator;
    const stdout = context.stdout();
    const stderr = context.stderr();

    // Validate format option
    const output_format = options.format orelse "text";
    if (!std.mem.eql(u8, output_format, "text") and !std.mem.eql(u8, output_format, "json")) {
        try stderr.print("Error: Invalid format '{s}'. Must be 'text' or 'json'.\n", .{output_format});
        return error.InvalidFormat;
    }

    const is_json = std.mem.eql(u8, output_format, "json");

    // Determine scan path
    const scan_path = options.path orelse ".";

    if (!is_json) {
        try stdout.print("ðŸ” Discovering environment variables in: {s}\n\n", .{scan_path});
    }

    // Initialize coordinator
    var coord = try Coordinator.init(allocator);
    defer coord.deinit();

    // Create progress tracking (auto-detects TTY and disables if piped/redirected)
    // Disable progress when outputting JSON
    const root_node = if (options.quiet or is_json)
        std.Progress.Node.none
    else
        std.Progress.start(.{
            .disable_printing = false,
        });
    defer if (root_node.index != .none) root_node.end();

    // Perform discovery
    var result = coord.discover(scan_path, root_node) catch |err| {
        try stderr.print("Error during discovery: {}\n", .{err});
        return err;
    };
    defer result.deinit();

    // Generate .env.example file if requested
    if (options.@"generate-env-example") |env_example_path_or_flag| {
        const env_example_path = if (env_example_path_or_flag.len == 0)
            ".env.example"
        else
            env_example_path_or_flag;

        try generateEnvExample(result, env_example_path, allocator, stdout, stderr);
    }

    // Output in requested format
    if (is_json) {
        try outputJson(result, options.verbose, allocator, stdout);
    } else {
        try outputText(result, options.verbose, stdout);
    }
}

fn generateEnvExample(
    result: discovery.DiscoveryResult,
    file_path: []const u8,
    allocator: std.mem.Allocator,
    stdout: anytype,
    stderr: anytype,
) !void {
    // Sort by name for consistent output
    const sorted_vars = try allocator.dupe(AggregatedEnvVar, result.env_vars);
    defer allocator.free(sorted_vars);
    std.mem.sort(AggregatedEnvVar, sorted_vars, {}, compareEnvVarsByName);

    // Create file
    const file = std.fs.cwd().createFile(file_path, .{}) catch |err| {
        try stderr.print("Error creating {s}: {}\n", .{ file_path, err });
        return err;
    };
    defer file.close();

    // Write header
    try file.writeAll("# Environment Variables Template\n");
    try file.writeAll("# Generated by ConfigFlow\n");
    try file.writeAll("#\n");
    try file.writeAll("# This file contains all environment variables discovered in your codebase.\n");
    try file.writeAll("# Copy this to .env and fill in the actual values.\n");
    try file.writeAll("#\n");

    const header = try std.fmt.allocPrint(allocator, "# Variables found: {}\n\n", .{sorted_vars.len});
    defer allocator.free(header);
    try file.writeAll(header);

    // Write each variable
    for (sorted_vars) |env_var| {
        // Write comment with type and confidence
        const comment = try std.fmt.allocPrint(
            allocator,
            "# Type: {s} (confidence: {s})\n",
            .{ env_var.inferred_type.toString(), env_var.confidence.toString() },
        );
        defer allocator.free(comment);
        try file.writeAll(comment);

        // Write variable with placeholder based on type
        const placeholder = getPlaceholder(env_var.inferred_type);
        const var_line = try std.fmt.allocPrint(allocator, "{s}={s}\n\n", .{ env_var.name, placeholder });
        defer allocator.free(var_line);
        try file.writeAll(var_line);
    }

    try stdout.print("âœ… Generated {s} with {} environment variables\n", .{ file_path, sorted_vars.len });
}

fn getPlaceholder(config_type: ConfigType) []const u8 {
    return switch (config_type) {
        .string => "\"\"",
        .integer => "0",
        .boolean => "false",
        .secret => "\"your-secret-here\"",
        .url => "\"https://example.com\"",
        .email => "\"user@example.com\"",
        .connection_string => "\"postgresql://user:password@localhost:5432/database\"",
    };
}

fn outputText(result: discovery.DiscoveryResult, verbose: bool, stdout: anytype) !void {
    // Display summary
    try stdout.print("ðŸ“Š Discovery Summary:\n", .{});
    try stdout.print("  Files scanned: {}\n", .{result.files_scanned});
    try stdout.print("  Environment variables found: {}\n", .{result.env_vars.len});
    try stdout.print("  Warnings: {}\n\n", .{result.warnings.len});

    if (result.env_vars.len == 0) {
        try stdout.print("No environment variables discovered.\n", .{});
        return;
    }

    // Display discovered environment variables
    try stdout.print("ðŸ“ Discovered Environment Variables:\n\n", .{});

    // Sort by name for consistent output
    const allocator = std.heap.page_allocator;
    const sorted_vars = try allocator.dupe(AggregatedEnvVar, result.env_vars);
    defer allocator.free(sorted_vars);

    std.mem.sort(AggregatedEnvVar, sorted_vars, {}, compareEnvVarsByName);

    for (sorted_vars) |env_var| {
        try printEnvVar(env_var, verbose, stdout);
    }

    // Display warnings if any
    if (result.warnings.len > 0) {
        try printWarningsSummary(result.warnings, stdout);
    }

    // Suggest next steps
    try stdout.print("\nðŸ’¡ Next Steps:\n", .{});
    try stdout.print("  1. Review the discovered variables above\n", .{});
    try stdout.print("  2. Run 'configflow init' to create a schema based on these discoveries\n", .{});
    try stdout.print("  3. Manually edit .configflow/schema.yml to refine types and add defaults\n", .{});
}

fn outputJson(result: discovery.DiscoveryResult, verbose: bool, allocator: std.mem.Allocator, stdout: anytype) !void {
    // Sort by name for consistent output
    const sorted_vars = try allocator.dupe(AggregatedEnvVar, result.env_vars);
    defer allocator.free(sorted_vars);
    std.mem.sort(AggregatedEnvVar, sorted_vars, {}, compareEnvVarsByName);

    try stdout.print("{{\n", .{});
    try stdout.print("  \"files_scanned\": {},\n", .{result.files_scanned});
    try stdout.print("  \"env_vars\": [\n", .{});

    for (sorted_vars, 0..) |env_var, i| {
        try stdout.print("    {{\n", .{});
        try stdout.print("      \"name\": \"{s}\",\n", .{env_var.name});
        try stdout.print("      \"inferred_type\": \"{s}\",\n", .{env_var.inferred_type.toString()});
        try stdout.print("      \"confidence\": \"{s}\"", .{env_var.confidence.toString()});

        // Add default values if any
        if (env_var.default_values.len > 0) {
            try stdout.print(",\n      \"default_values\": [", .{});
            for (env_var.default_values, 0..) |val, idx| {
                if (idx > 0) try stdout.print(", ", .{});
                try stdout.print("\"{s}\"", .{val});
            }
            try stdout.print("]", .{});
        }

        if (verbose) {
            try stdout.print(",\n      \"locations\": [\n", .{});
            for (env_var.locations, 0..) |loc, j| {
                try stdout.print("        {{\n", .{});
                try stdout.print("          \"file_path\": \"{s}\",\n", .{loc.file_path});
                try stdout.print("          \"line_number\": {}", .{loc.line_number});
                if (loc.context) |ctx| {
                    // Escape quotes and backslashes in context
                    try stdout.print(",\n          \"context\": \"", .{});
                    for (ctx) |c| {
                        if (c == '"') {
                            try stdout.print("\\\"", .{});
                        } else if (c == '\\') {
                            try stdout.print("\\\\", .{});
                        } else if (c == '\n') {
                            try stdout.print("\\n", .{});
                        } else if (c == '\r') {
                            try stdout.print("\\r", .{});
                        } else if (c == '\t') {
                            try stdout.print("\\t", .{});
                        } else {
                            try stdout.print("{c}", .{c});
                        }
                    }
                    try stdout.print("\"", .{});
                }
                if (loc.default_value) |val| {
                    try stdout.print(",\n          \"default_value\": \"{s}\"", .{val});
                }
                try stdout.print("\n        }}", .{});
                if (j < env_var.locations.len - 1) {
                    try stdout.print(",", .{});
                }
                try stdout.print("\n", .{});
            }
            try stdout.print("      ]\n", .{});
        } else {
            try stdout.print("\n", .{});
        }

        try stdout.print("    }}", .{});
        if (i < sorted_vars.len - 1) {
            try stdout.print(",", .{});
        }
        try stdout.print("\n", .{});
    }

    try stdout.print("  ],\n", .{});
    try stdout.print("  \"warnings\": [\n", .{});

    for (result.warnings, 0..) |warning, i| {
        try stdout.print("    {{\n", .{});
        try stdout.print("      \"type\": \"{s}\",\n", .{@tagName(warning.warning_type)});
        // Escape quotes and backslashes in message
        try stdout.print("      \"message\": \"", .{});
        for (warning.message) |c| {
            if (c == '"') {
                try stdout.print("\\\"", .{});
            } else if (c == '\\') {
                try stdout.print("\\\\", .{});
            } else if (c == '\n') {
                try stdout.print("\\n", .{});
            } else if (c == '\r') {
                try stdout.print("\\r", .{});
            } else if (c == '\t') {
                try stdout.print("\\t", .{});
            } else {
                try stdout.print("{c}", .{c});
            }
        }
        try stdout.print("\",\n", .{});
        try stdout.print("      \"file_path\": \"{s}\",\n", .{warning.file_path});
        try stdout.print("      \"line_number\": {}\n", .{warning.line_number});
        try stdout.print("    }}", .{});
        if (i < result.warnings.len - 1) {
            try stdout.print(",", .{});
        }
        try stdout.print("\n", .{});
    }

    try stdout.print("  ]\n", .{});
    try stdout.print("}}\n", .{});
}

fn printEnvVar(env_var: AggregatedEnvVar, verbose: bool, stdout: anytype) !void {
    // Print variable name in bold
    try stdout.print("  \x1b[1m{s}\x1b[0m\n", .{env_var.name});
    try stdout.print("    Inferred Type: {s} (inference confidence: {s})\n", .{
        env_var.inferred_type.toString(),
        env_var.confidence.toString(),
    });

    // Print default values if any
    if (env_var.default_values.len > 0) {
        try stdout.print("    Default Value(s): ", .{});
        for (env_var.default_values, 0..) |val, idx| {
            if (idx > 0) try stdout.print(", ", .{});
            try stdout.print("\"{s}\"", .{val});
        }
        try stdout.print("\n", .{});
    }

    if (verbose) {
        try stdout.print("    Found in {} location(s):\n", .{env_var.locations.len});
        for (env_var.locations) |loc| {
            try stdout.print("      - {s}:{}\n", .{ loc.file_path, loc.line_number });
            if (loc.context) |ctx| {
                try stdout.print("        {s}\n", .{ctx});
            }
            if (loc.default_value) |val| {
                try stdout.print("        Default: \"{s}\"\n", .{val});
            }
        }
    } else {
        try stdout.print("    Locations: {} occurrence(s)\n", .{env_var.locations.len});
    }

    try stdout.print("\n", .{});
}

fn printWarningsSummary(warnings: []Warning, stdout: anytype) !void {
    try stdout.print("\nâš ï¸  Warnings:\n\n", .{});

    // Group warnings by type
    const allocator = std.heap.page_allocator;
    var string_interpolation = std.ArrayList(Warning){};
    var dynamic_access = std.ArrayList(Warning){};
    var computed_key = std.ArrayList(Warning){};
    var unknown = std.ArrayList(Warning){};
    defer string_interpolation.deinit(allocator);
    defer dynamic_access.deinit(allocator);
    defer computed_key.deinit(allocator);
    defer unknown.deinit(allocator);

    for (warnings) |warning| {
        if (std.mem.indexOf(u8, warning.message, "string interpolation") != null) {
            try string_interpolation.append(allocator, warning);
        } else if (warning.warning_type == .dynamic_access) {
            try dynamic_access.append(allocator, warning);
        } else if (warning.warning_type == .computed_key) {
            try computed_key.append(allocator, warning);
        } else {
            try unknown.append(allocator, warning);
        }
    }

    // Print string interpolation warnings
    if (string_interpolation.items.len > 0) {
        try stdout.print("  Dynamic Access - String Interpolation ({} occurrence(s)):\n", .{string_interpolation.items.len});
        try stdout.print("    Environment variable keys are constructed using string interpolation and cannot be\n", .{});
        try stdout.print("    statically analyzed. Consider using static keys or documenting these variables.\n\n", .{});
        for (string_interpolation.items) |warning| {
            try stdout.print("      - {s}:{}\n", .{ warning.file_path, warning.line_number });
        }
        try stdout.print("\n", .{});
    }

    // Print other dynamic access warnings
    if (dynamic_access.items.len > 0) {
        try stdout.print("  Dynamic Access - Variable Key ({} occurrence(s)):\n", .{dynamic_access.items.len});
        try stdout.print("    Environment variable keys are passed as variables and cannot be statically analyzed.\n\n", .{});
        for (dynamic_access.items) |warning| {
            try stdout.print("      - {s}:{}\n", .{ warning.file_path, warning.line_number });
        }
        try stdout.print("\n", .{});
    }

    // Print computed key warnings
    if (computed_key.items.len > 0) {
        try stdout.print("  Computed Keys ({} occurrence(s)):\n", .{computed_key.items.len});
        try stdout.print("    Environment variable keys are computed at runtime.\n\n", .{});
        for (computed_key.items) |warning| {
            try stdout.print("      - {s}:{}\n", .{ warning.file_path, warning.line_number });
        }
        try stdout.print("\n", .{});
    }

    // Print unknown pattern warnings
    if (unknown.items.len > 0) {
        try stdout.print("  Unknown Patterns ({} occurrence(s)):\n\n", .{unknown.items.len});
        for (unknown.items) |warning| {
            try stdout.print("      - {s}:{} - {s}\n", .{ warning.file_path, warning.line_number, warning.message });
        }
        try stdout.print("\n", .{});
    }
}

fn compareEnvVarsByName(_: void, a: AggregatedEnvVar, b: AggregatedEnvVar) bool {
    return std.mem.order(u8, a.name, b.name) == .lt;
}
