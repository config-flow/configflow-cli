const std = @import("std");
const zcli = @import("zcli");
const yaml = @import("yaml");
const discovery = @import("discovery");

pub const meta = .{
    .description = "Initialize ConfigFlow in the current directory",
    .examples = &.{
        "configflow init",
        "configflow init --force",
    },
    .options = .{
        .force = .{ .description = "Force re-initialization even if .configflow exists", .short = 'f' },
    },
};

pub const Args = struct {};

pub const Options = struct {
    force: bool = false,
};

pub fn execute(_: Args, options: Options, context: *zcli.Context) !void {
    const allocator = context.allocator;
    const stdout = context.stdout();
    const stderr = context.stderr();

    // Check if .configflow already exists
    const configflow_dir = ".configflow";
    const dir_exists = checkDirExists(configflow_dir);

    if (dir_exists and !options.force) {
        try stderr.print("Error: .configflow directory already exists.\n", .{});
        try stderr.print("Use --force to reinitialize.\n", .{});
        return error.AlreadyInitialized;
    }

    if (dir_exists and options.force) {
        try stdout.print("Reinitializing .configflow directory...\n", .{});
    } else {
        try stdout.print("Initializing ConfigFlow...\n", .{});
    }

    // Discover environment variables from all sources
    const entries = try discoverAllSources(allocator, stdout, stderr);
    defer {
        for (entries) |entry| {
            allocator.free(entry.key);
            allocator.free(entry.value);
            if (entry.default_value) |val| {
                allocator.free(val);
            }
        }
        allocator.free(entries);
    }

    if (entries.len == 0) {
        try stdout.print("\n No environment variables found.\n", .{});
        try stdout.print("ConfigFlow couldn't find any environment variables in your codebase or .env file.\n", .{});
        try stdout.print("Make sure you're in the right directory.\n", .{});
        return;
    }

    try stdout.print("Found {} environment variable(s)\n\n", .{entries.len});

    // Display inferred types
    try stdout.print("Inferred types:\n", .{});
    for (entries) |entry| {
        try stdout.print("  {s}: {s} (type: {s})\n", .{
            entry.key,
            if (entry.inferred_type == .secret) "***" else entry.value,
            @tagName(entry.inferred_type),
        });
    }

    // Interactive wizard
    try stdout.print("\n--- Interactive Configuration Wizard ---\n", .{});
    try stdout.print("Let's configure each variable. Press Enter to accept defaults.\n\n", .{});

    const config_entries = try runWizard(allocator, context, entries);
    defer {
        for (config_entries) |entry| {
            entry.deinit(allocator);
        }
        allocator.free(config_entries);
    }

    try stdout.print("\n--- Configuration Summary ---\n", .{});
    for (config_entries) |entry| {
        try stdout.print("{s}: {s} ({s})\n", .{
            entry.key,
            @tagName(entry.config_type),
            if (entry.required) "required" else "optional",
        });
        if (entry.description.len > 0) {
            try stdout.print("  Description: {s}\n", .{entry.description});
        }
    }

    // Create .configflow directory
    try stdout.print("\nCreating .configflow directory...\n", .{});
    std.fs.cwd().makeDir(configflow_dir) catch |err| switch (err) {
        error.PathAlreadyExists => {}, // OK if already exists (force mode)
        else => return err,
    };

    // Generate schema.yml
    try stdout.print("Generating schema.yml...\n", .{});
    try generateSchemaYaml(allocator, config_entries);

    // Prompt for output configuration
    try stdout.print("\n--- Output Configuration ---\n", .{});

    var stdin_buffer: [4096]u8 = undefined;
    var stdin_reader = std.fs.File.stdin().reader(&stdin_buffer);
    const stdin_final = &stdin_reader.interface;

    try stdout.print("Output format (env/yaml/json) [env]: ", .{});
    const format_input = try readLine(allocator, stdin_final);
    defer allocator.free(format_input);
    const output_format = if (format_input.len == 0) "env" else format_input;

    try stdout.print("Output path [.env]: ", .{});
    const path_input = try readLine(allocator, stdin_final);
    defer allocator.free(path_input);
    const output_path = if (path_input.len == 0) ".env" else path_input;

    // Generate config.yml
    try stdout.print("\nGenerating config.yml...\n", .{});
    try generateConfigYaml(allocator, output_format, output_path);

    // Warn about .env
    if (std.mem.eql(u8, output_path, ".env")) {
        try stdout.print("\nâš ï¸  WARNING: .env will be auto-generated by ConfigFlow\n", .{});
        try stdout.print("   Do not manually edit .env - your changes will be overwritten.\n", .{});
        try stdout.print("   To make changes, update .configflow/schema.yml and run 'configflow sync'\n", .{});
    }

    try stdout.print("\nâœ“ ConfigFlow initialized successfully!\n", .{});
    try stdout.print("Configuration schema saved to .configflow/schema.yml\n", .{});
    try stdout.print("Output configuration saved to .configflow/config.yml\n", .{});
}

fn discoverAllSources(allocator: std.mem.Allocator, stdout: anytype, stderr: anytype) ![]EnvEntry {
    _ = stderr;

    try stdout.print("\nðŸ” Discovering environment variables...\n", .{});

    // Track discovered variables by name to deduplicate
    var discovered_vars = std.StringHashMap(EnvEntry).init(allocator);
    defer {
        var it = discovered_vars.iterator();
        while (it.next()) |entry| {
            allocator.free(entry.key_ptr.*);
            allocator.free(entry.value_ptr.key);
            allocator.free(entry.value_ptr.value);
        }
        discovered_vars.deinit();
    }

    // 1. Discover from source code
    try stdout.print("  â€¢ Scanning source code...\n", .{});
    var coord = try discovery.Coordinator.init(allocator);
    defer coord.deinit();

    const result = discover_result: {
        break :discover_result coord.discover(".", std.Progress.Node.none) catch |err| {
            // If discovery fails, continue with just .env
            try stdout.print("    Warning: Source code discovery failed: {}\n", .{err});
            break :discover_result discovery.DiscoveryResult{
                .env_vars = &.{},
                .warnings = &.{},
                .files_scanned = 0,
                .allocator = allocator,
            };
        };
    };
    defer {
        var mut_result = result;
        mut_result.deinit();
    }

    if (result.env_vars.len > 0) {
        try stdout.print("    Found {} variable(s) in {} file(s)\n", .{ result.env_vars.len, result.files_scanned });

        // Add discovered variables
        for (result.env_vars) |env_var| {
            // Extract first default value if any were detected
            const default_value = if (env_var.default_values.len > 0)
                try allocator.dupe(u8, env_var.default_values[0])
            else
                null;

            const entry = EnvEntry{
                .key = try allocator.dupe(u8, env_var.name),
                .value = try getValueForVariable(allocator, env_var.name, env_var.inferred_type),
                .inferred_type = mapDiscoveryTypeToConfigType(env_var.inferred_type),
                .default_value = default_value,
            };

            // Store with key duplication for the hashmap
            const key = try allocator.dupe(u8, env_var.name);
            try discovered_vars.put(key, entry);
        }
    }

    // 2. Parse .env file if it exists
    const env_path = ".env";
    if (checkFileExists(env_path)) {
        try stdout.print("  â€¢ Parsing .env file...\n", .{});

        const env_contents = try readFile(allocator, env_path);
        defer allocator.free(env_contents);

        const env_entries = try parseEnvFile(allocator, env_contents);
        defer {
            for (env_entries) |entry| {
                allocator.free(entry.key);
                allocator.free(entry.value);
                if (entry.default_value) |val| {
                    allocator.free(val);
                }
            }
            allocator.free(env_entries);
        }

        try stdout.print("    Found {} variable(s)\n", .{env_entries.len});

        // Merge .env entries
        for (env_entries) |env_entry| {
            if (discovered_vars.getPtr(env_entry.key)) |existing| {
                // Variable already discovered in code - update value with .env value
                allocator.free(existing.value);
                existing.value = try allocator.dupe(u8, env_entry.value);
            } else {
                // New variable from .env - add it (no default value since not in code)
                const entry = EnvEntry{
                    .key = try allocator.dupe(u8, env_entry.key),
                    .value = try allocator.dupe(u8, env_entry.value),
                    .inferred_type = env_entry.inferred_type,
                    .default_value = null,
                };
                const key = try allocator.dupe(u8, env_entry.key);
                try discovered_vars.put(key, entry);
            }
        }
    }

    // Convert hashmap to array
    var final_entries = std.ArrayList(EnvEntry){};
    defer final_entries.deinit(allocator);

    var it = discovered_vars.valueIterator();
    while (it.next()) |entry| {
        // Duplicate default value if it exists
        const default_value = if (entry.default_value) |val|
            try allocator.dupe(u8, val)
        else
            null;

        try final_entries.append(allocator, .{
            .key = try allocator.dupe(u8, entry.key),
            .value = try allocator.dupe(u8, entry.value),
            .inferred_type = entry.inferred_type,
            .default_value = default_value,
        });
    }

    return final_entries.toOwnedSlice(allocator);
}

fn getValueForVariable(allocator: std.mem.Allocator, var_name: []const u8, var_type: discovery.ConfigType) ![]u8 {
    // Try to get value from shell environment
    if (std.process.getEnvVarOwned(allocator, var_name)) |value| {
        return value;
    } else |_| {
        // Not in environment - return placeholder based on type
        return allocator.dupe(u8, getPlaceholderValue(var_type));
    }
}

fn mapDiscoveryTypeToConfigType(discovery_type: discovery.ConfigType) ConfigType {
    return switch (discovery_type) {
        .string => .string,
        .integer => .integer,
        .boolean => .boolean,
        .url => .url,
        .connection_string => .connection_string,
        .secret => .secret,
        .email => .string, // Map email to string for now
    };
}

fn getPlaceholderValue(config_type: discovery.ConfigType) []const u8 {
    return switch (config_type) {
        .string => "",
        .integer => "0",
        .boolean => "false",
        .url => "https://example.com",
        .connection_string => "postgresql://user:password@localhost:5432/database",
        .secret => "your-secret-here",
        .email => "user@example.com",
    };
}

fn generateConfigYaml(allocator: std.mem.Allocator, format: []const u8, path: []const u8) !void {
    var yaml_content = std.ArrayList(u8){};
    defer yaml_content.deinit(allocator);

    const writer = yaml_content.writer(allocator);

    // Write header
    try writer.writeAll("# ConfigFlow Output Configuration\n");
    try writer.writeAll("# Generated by configflow init\n\n");

    // Write output configuration
    try writer.writeAll("output:\n");
    try writer.print("  format: {s}\n", .{format});
    try writer.print("  path: {s}\n", .{path});

    // Write to file
    const file = try std.fs.cwd().createFile(".configflow/config.yml", .{});
    defer file.close();

    const contents = try yaml_content.toOwnedSlice(allocator);
    defer allocator.free(contents);

    try file.writeAll(contents);
}

fn generateSchemaYaml(allocator: std.mem.Allocator, entries: []ConfigEntry) !void {
    var yaml_content = std.ArrayList(u8){};
    defer yaml_content.deinit(allocator);

    const writer = yaml_content.writer(allocator);

    // Write header
    try writer.writeAll("# ConfigFlow Schema\n");
    try writer.writeAll("# Generated by configflow init\n\n");

    // Write sources section
    try writer.writeAll("sources:\n");
    try writer.writeAll("  local:\n");
    try writer.writeAll("    type: file\n");
    try writer.writeAll("    path: .env.local\n");
    try writer.writeAll("  staging:\n");
    try writer.writeAll("    type: env\n");
    try writer.writeAll("  prod:\n");
    try writer.writeAll("    type: env\n");
    try writer.writeAll("\n");

    try writer.writeAll("config:\n");

    // Write each config entry
    for (entries) |entry| {
        try writer.print("  {s}:\n", .{entry.key});
        try writer.print("    type: {s}\n", .{@tagName(entry.config_type)});
        try writer.print("    required: {s}\n", .{if (entry.required) "true" else "false"});

        if (entry.description.len > 0) {
            try writer.print("    description: \"{s}\"\n", .{entry.description});
        }

        // Add default value if detected from code
        if (entry.default_value) |default_val| {
            try writer.print("    default: \"{s}\"  # Detected from code\n", .{default_val});
        }

        // Add source mappings (reference the sources defined above)
        try writer.writeAll("    sources:\n");
        try writer.writeAll("      local: local\n");
        try writer.writeAll("      staging: staging\n");
        try writer.writeAll("      prod: prod\n");

        // Add validation section (empty for now)
        try writer.writeAll("    validation:\n");
        try writer.writeAll("      format: null  # TODO: Add format validation if needed\n");
        try writer.writeAll("      pattern: null  # TODO: Add pattern validation if needed\n");
        try writer.writeAll("\n");
    }

    // Write to file
    const file = try std.fs.cwd().createFile(".configflow/schema.yml", .{});
    defer file.close();

    const contents = try yaml_content.toOwnedSlice(allocator);
    defer allocator.free(contents);

    try file.writeAll(contents);
}

fn runWizard(allocator: std.mem.Allocator, context: *zcli.Context, entries: []EnvEntry) ![]ConfigEntry {
    var config_entries = std.ArrayList(ConfigEntry){};
    defer config_entries.deinit(allocator);

    const stdout = context.stdout();

    for (entries) |entry| {
        try stdout.print("--- Configuring: {s} ---\n", .{entry.key});

        // Type confirmation
        try stdout.print("Inferred type: {s}\n", .{@tagName(entry.inferred_type)});
        try stdout.print("Type (string/secret/integer/boolean/url/connection_string/json) [{s}]: ", .{@tagName(entry.inferred_type)});

        // Create fresh reader for each prompt to avoid buffering issues
        var type_buffer: [4096]u8 = undefined;
        var type_reader = std.fs.File.stdin().reader(&type_buffer);
        const type_input = try readLine(allocator, &type_reader.interface);
        defer allocator.free(type_input);

        const config_type = if (type_input.len == 0)
            entry.inferred_type
        else
            ConfigType.fromString(type_input) orelse entry.inferred_type;

        // Required confirmation
        try stdout.print("Required? (y/n) [y]: ", .{});
        var required_buffer: [4096]u8 = undefined;
        var required_reader = std.fs.File.stdin().reader(&required_buffer);
        const required_input = try readLine(allocator, &required_reader.interface);
        defer allocator.free(required_input);

        const required = if (required_input.len == 0)
            true
        else
            std.mem.eql(u8, required_input, "y") or std.mem.eql(u8, required_input, "yes");

        // Description
        try stdout.print("Description (optional): ", .{});
        var desc_buffer: [4096]u8 = undefined;
        var desc_reader = std.fs.File.stdin().reader(&desc_buffer);
        const description = try readLine(allocator, &desc_reader.interface);

        // Extract default value if it exists in the entry
        const default_value = if (entry.default_value) |val|
            try allocator.dupe(u8, val)
        else
            null;

        try config_entries.append(allocator, .{
            .key = try allocator.dupe(u8, entry.key),
            .config_type = config_type,
            .required = required,
            .description = description,
            .default_value = default_value,
        });

        try stdout.print("\n", .{});
    }

    return config_entries.toOwnedSlice(allocator);
}

fn readLine(allocator: std.mem.Allocator, reader: anytype) ![]u8 {
    const line = reader.takeDelimiterExclusive('\n') catch |err| switch (err) {
        error.EndOfStream => return allocator.dupe(u8, ""),
        error.StreamTooLong => return error.LineTooLong,
        error.ReadFailed => return error.ReadFailed,
    };

    const trimmed = std.mem.trim(u8, line, " \t\r\n");
    return allocator.dupe(u8, trimmed);
}

fn checkDirExists(path: []const u8) bool {
    var dir = std.fs.cwd().openDir(path, .{}) catch return false;
    dir.close();
    return true;
}

fn checkFileExists(path: []const u8) bool {
    var file = std.fs.cwd().openFile(path, .{}) catch return false;
    file.close();
    return true;
}

fn readFile(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const stat = try file.stat();
    const contents = try file.readToEndAlloc(allocator, stat.size);
    return contents;
}

const ConfigType = enum {
    string,
    secret,
    integer,
    boolean,
    url,
    connection_string,
    json,

    pub fn fromString(s: []const u8) ?ConfigType {
        if (std.mem.eql(u8, s, "string")) return .string;
        if (std.mem.eql(u8, s, "secret")) return .secret;
        if (std.mem.eql(u8, s, "integer")) return .integer;
        if (std.mem.eql(u8, s, "boolean")) return .boolean;
        if (std.mem.eql(u8, s, "url")) return .url;
        if (std.mem.eql(u8, s, "connection_string")) return .connection_string;
        if (std.mem.eql(u8, s, "json")) return .json;
        return null;
    }
};

const EnvEntry = struct {
    key: []u8,
    value: []u8,
    inferred_type: ConfigType,
    default_value: ?[]u8,
};

const ConfigEntry = struct {
    key: []u8,
    config_type: ConfigType,
    required: bool,
    description: []u8,
    default_value: ?[]u8,

    fn deinit(self: ConfigEntry, allocator: std.mem.Allocator) void {
        allocator.free(self.key);
        allocator.free(self.description);
        if (self.default_value) |val| {
            allocator.free(val);
        }
    }
};

fn inferType(value: []const u8) ConfigType {
    // Check for boolean
    if (std.mem.eql(u8, value, "true") or std.mem.eql(u8, value, "false")) {
        return .boolean;
    }

    // Check for integer
    if (std.fmt.parseInt(i64, value, 10)) |_| {
        return .integer;
    } else |_| {}

    // Check for connection string
    if (std.mem.startsWith(u8, value, "postgresql://") or
        std.mem.startsWith(u8, value, "mysql://") or
        std.mem.startsWith(u8, value, "mongodb://") or
        std.mem.startsWith(u8, value, "redis://"))
    {
        return .connection_string;
    }

    // Check for URL
    if (std.mem.startsWith(u8, value, "http://") or
        std.mem.startsWith(u8, value, "https://"))
    {
        return .url;
    }

    // Check for JSON (simple heuristic: starts with { or [)
    if (value.len > 0 and (value[0] == '{' or value[0] == '[')) {
        return .json;
    }

    // Check for secret (long alphanumeric strings)
    if (value.len > 20) {
        var is_secret = true;
        for (value) |c| {
            if (!std.ascii.isAlphanumeric(c) and c != '_' and c != '-') {
                is_secret = false;
                break;
            }
        }
        if (is_secret) return .secret;
    }

    // Default to string
    return .string;
}

fn parseEnvFile(allocator: std.mem.Allocator, contents: []const u8) ![]EnvEntry {
    var entries = std.ArrayList(EnvEntry){};
    defer entries.deinit(allocator);

    var lines = std.mem.splitScalar(u8, contents, '\n');
    while (lines.next()) |line| {
        const trimmed = std.mem.trim(u8, line, " \t\r");

        // Skip empty lines and comments
        if (trimmed.len == 0 or trimmed[0] == '#') continue;

        // Find the '=' separator
        if (std.mem.indexOfScalar(u8, trimmed, '=')) |eq_pos| {
            const key = std.mem.trim(u8, trimmed[0..eq_pos], " \t");
            const value = std.mem.trim(u8, trimmed[eq_pos + 1 ..], " \t");

            // Skip if key is empty
            if (key.len == 0) continue;

            const inferred = inferType(value);

            try entries.append(allocator, .{
                .key = try allocator.dupe(u8, key),
                .value = try allocator.dupe(u8, value),
                .inferred_type = inferred,
                .default_value = null, // .env files don't have code-detected defaults
            });
        }
    }

    return entries.toOwnedSlice(allocator);
}

// Tests
test "inferType - boolean" {
    try std.testing.expectEqual(ConfigType.boolean, inferType("true"));
    try std.testing.expectEqual(ConfigType.boolean, inferType("false"));
}

test "inferType - integer" {
    try std.testing.expectEqual(ConfigType.integer, inferType("42"));
    try std.testing.expectEqual(ConfigType.integer, inferType("0"));
    try std.testing.expectEqual(ConfigType.integer, inferType("-123"));
}

test "inferType - connection_string" {
    try std.testing.expectEqual(ConfigType.connection_string, inferType("postgresql://localhost:5432/db"));
    try std.testing.expectEqual(ConfigType.connection_string, inferType("mysql://host/db"));
    try std.testing.expectEqual(ConfigType.connection_string, inferType("mongodb://host/db"));
}

test "inferType - url" {
    try std.testing.expectEqual(ConfigType.url, inferType("https://example.com"));
    try std.testing.expectEqual(ConfigType.url, inferType("http://localhost:3000"));
}

test "inferType - secret" {
    try std.testing.expectEqual(ConfigType.secret, inferType("sk_test_4eC39HqLyjWDarjtT1zdp7dc"));
    try std.testing.expectEqual(ConfigType.secret, inferType("verylongsecretkey1234567890abc"));
}

test "inferType - json" {
    try std.testing.expectEqual(ConfigType.json, inferType("{\"key\": \"value\"}"));
    try std.testing.expectEqual(ConfigType.json, inferType("[1, 2, 3]"));
    try std.testing.expectEqual(ConfigType.json, inferType("{}"));
    try std.testing.expectEqual(ConfigType.json, inferType("[]"));
}

test "inferType - string" {
    try std.testing.expectEqual(ConfigType.string, inferType("hello"));
    try std.testing.expectEqual(ConfigType.string, inferType("short"));
    try std.testing.expectEqual(ConfigType.string, inferType(""));
    try std.testing.expectEqual(ConfigType.string, inferType("with spaces"));
}

test "inferType - edge cases" {
    // Integer-like but not integer
    try std.testing.expectEqual(ConfigType.string, inferType("12.34"));
    try std.testing.expectEqual(ConfigType.string, inferType("123abc"));

    // Boolean-like but not boolean
    try std.testing.expectEqual(ConfigType.string, inferType("True"));
    try std.testing.expectEqual(ConfigType.string, inferType("FALSE"));
    try std.testing.expectEqual(ConfigType.string, inferType("yes"));

    // URL-like but not URL
    try std.testing.expectEqual(ConfigType.string, inferType("ftp://example.com"));

    // Connection string variants
    try std.testing.expectEqual(ConfigType.connection_string, inferType("redis://localhost:6379"));

    // Secret with special chars should not be secret
    try std.testing.expectEqual(ConfigType.string, inferType("short@with#special!"));

    // Long string with spaces is not a secret
    try std.testing.expectEqual(ConfigType.string, inferType("this is a very long string with spaces"));
}

test "parseEnvFile - basic" {
    const allocator = std.testing.allocator;

    const input =
        \\DATABASE_URL=postgresql://localhost:5432/mydb
        \\API_KEY=secret123456789012345678901234567890
        \\DEBUG=true
    ;

    const entries = try parseEnvFile(allocator, input);
    defer {
        for (entries) |entry| {
            allocator.free(entry.key);
            allocator.free(entry.value);
            if (entry.default_value) |val| {
                allocator.free(val);
            }
        }
        allocator.free(entries);
    }

    try std.testing.expectEqual(@as(usize, 3), entries.len);
    try std.testing.expectEqualStrings("DATABASE_URL", entries[0].key);
    try std.testing.expectEqualStrings("postgresql://localhost:5432/mydb", entries[0].value);
    try std.testing.expectEqual(ConfigType.connection_string, entries[0].inferred_type);
    try std.testing.expectEqual(ConfigType.secret, entries[1].inferred_type);
    try std.testing.expectEqual(ConfigType.boolean, entries[2].inferred_type);
}

test "parseEnvFile - with comments and empty lines" {
    const allocator = std.testing.allocator;

    const input =
        \\# This is a comment
        \\DATABASE_URL=postgresql://localhost:5432/mydb
        \\
        \\# Another comment
        \\API_KEY=secret123
    ;

    const entries = try parseEnvFile(allocator, input);
    defer {
        for (entries) |entry| {
            allocator.free(entry.key);
            allocator.free(entry.value);
            if (entry.default_value) |val| {
                allocator.free(val);
            }
        }
        allocator.free(entries);
    }

    try std.testing.expectEqual(@as(usize, 2), entries.len);
}

test "parseEnvFile - with spaces" {
    const allocator = std.testing.allocator;

    const input = "  DATABASE_URL  =  postgresql://localhost:5432/mydb  ";

    const entries = try parseEnvFile(allocator, input);
    defer {
        for (entries) |entry| {
            allocator.free(entry.key);
            allocator.free(entry.value);
            if (entry.default_value) |val| {
                allocator.free(val);
            }
        }
        allocator.free(entries);
    }

    try std.testing.expectEqual(@as(usize, 1), entries.len);
    try std.testing.expectEqualStrings("DATABASE_URL", entries[0].key);
    try std.testing.expectEqualStrings("postgresql://localhost:5432/mydb", entries[0].value);
}

test "parseEnvFile - edge cases" {
    const allocator = std.testing.allocator;

    const input =
        \\# Comment at start
        \\
        \\VALID_KEY=value
        \\=no_key
        \\NO_VALUE=
        \\  =
        \\ANOTHER_VALID=test
        \\NO_EQUALS_SIGN
    ;

    const entries = try parseEnvFile(allocator, input);
    defer {
        for (entries) |entry| {
            allocator.free(entry.key);
            allocator.free(entry.value);
            if (entry.default_value) |val| {
                allocator.free(val);
            }
        }
        allocator.free(entries);
    }

    // Should only have the valid entries
    try std.testing.expectEqual(@as(usize, 3), entries.len);
    try std.testing.expectEqualStrings("VALID_KEY", entries[0].key);
    try std.testing.expectEqualStrings("value", entries[0].value);
    try std.testing.expectEqualStrings("NO_VALUE", entries[1].key);
    try std.testing.expectEqualStrings("", entries[1].value);
    try std.testing.expectEqualStrings("ANOTHER_VALID", entries[2].key);
    try std.testing.expectEqualStrings("test", entries[2].value);
}

test "parseEnvFile - empty input" {
    const allocator = std.testing.allocator;

    const input = "";

    const entries = try parseEnvFile(allocator, input);
    defer allocator.free(entries);

    try std.testing.expectEqual(@as(usize, 0), entries.len);
}

test "parseEnvFile - only comments" {
    const allocator = std.testing.allocator;

    const input =
        \\# Comment 1
        \\# Comment 2
        \\
        \\# Comment 3
    ;

    const entries = try parseEnvFile(allocator, input);
    defer allocator.free(entries);

    try std.testing.expectEqual(@as(usize, 0), entries.len);
}

test "parseEnvFile - values with equals signs" {
    const allocator = std.testing.allocator;

    const input = "BASE64=abc=def=ghi";

    const entries = try parseEnvFile(allocator, input);
    defer {
        for (entries) |entry| {
            allocator.free(entry.key);
            allocator.free(entry.value);
            if (entry.default_value) |val| {
                allocator.free(val);
            }
        }
        allocator.free(entries);
    }

    try std.testing.expectEqual(@as(usize, 1), entries.len);
    try std.testing.expectEqualStrings("BASE64", entries[0].key);
    try std.testing.expectEqualStrings("abc=def=ghi", entries[0].value);
}

test "parseEnvFile - special characters in values" {
    const allocator = std.testing.allocator;

    const input =
        \\URL=https://example.com?param=value&other=test
        \\PATH=/usr/local/bin:/usr/bin
        \\JSON={"key":"value"}
    ;

    const entries = try parseEnvFile(allocator, input);
    defer {
        for (entries) |entry| {
            allocator.free(entry.key);
            allocator.free(entry.value);
            if (entry.default_value) |val| {
                allocator.free(val);
            }
        }
        allocator.free(entries);
    }

    try std.testing.expectEqual(@as(usize, 3), entries.len);
    try std.testing.expectEqualStrings("URL", entries[0].key);
    try std.testing.expectEqualStrings("https://example.com?param=value&other=test", entries[0].value);
    try std.testing.expectEqualStrings("PATH", entries[1].key);
    try std.testing.expectEqualStrings("/usr/local/bin:/usr/bin", entries[1].value);
    try std.testing.expectEqualStrings("JSON", entries[2].key);
    try std.testing.expectEqualStrings("{\"key\":\"value\"}", entries[2].value);
}

test "parseEnvFile - windows line endings" {
    const allocator = std.testing.allocator;

    const input = "KEY1=value1\r\nKEY2=value2\r\n";

    const entries = try parseEnvFile(allocator, input);
    defer {
        for (entries) |entry| {
            allocator.free(entry.key);
            allocator.free(entry.value);
            if (entry.default_value) |val| {
                allocator.free(val);
            }
        }
        allocator.free(entries);
    }

    try std.testing.expectEqual(@as(usize, 2), entries.len);
    try std.testing.expectEqualStrings("KEY1", entries[0].key);
    try std.testing.expectEqualStrings("value1", entries[0].value);
    try std.testing.expectEqualStrings("KEY2", entries[1].key);
    try std.testing.expectEqualStrings("value2", entries[1].value);
}

test "parseEnvFile - no trailing newline" {
    const allocator = std.testing.allocator;

    const input = "KEY=value";

    const entries = try parseEnvFile(allocator, input);
    defer {
        for (entries) |entry| {
            allocator.free(entry.key);
            allocator.free(entry.value);
            if (entry.default_value) |val| {
                allocator.free(val);
            }
        }
        allocator.free(entries);
    }

    try std.testing.expectEqual(@as(usize, 1), entries.len);
    try std.testing.expectEqualStrings("KEY", entries[0].key);
    try std.testing.expectEqualStrings("value", entries[0].value);
}

test "parseEnvFile - mixed valid and invalid lines" {
    const allocator = std.testing.allocator;

    const input =
        \\VALID1=value1
        \\INVALID LINE WITHOUT EQUALS
        \\=INVALID_NO_KEY
        \\VALID2=value2
        \\
        \\VALID3=
    ;

    const entries = try parseEnvFile(allocator, input);
    defer {
        for (entries) |entry| {
            allocator.free(entry.key);
            allocator.free(entry.value);
            if (entry.default_value) |val| {
                allocator.free(val);
            }
        }
        allocator.free(entries);
    }

    try std.testing.expectEqual(@as(usize, 3), entries.len);
    try std.testing.expectEqualStrings("VALID1", entries[0].key);
    try std.testing.expectEqualStrings("VALID2", entries[1].key);
    try std.testing.expectEqualStrings("VALID3", entries[2].key);
    try std.testing.expectEqualStrings("", entries[2].value);
}

test "parseEnvFile - very long values" {
    const allocator = std.testing.allocator;

    const long_value = "a" ** 1000;
    const input = try std.fmt.allocPrint(allocator, "KEY={s}", .{long_value});
    defer allocator.free(input);

    const entries = try parseEnvFile(allocator, input);
    defer {
        for (entries) |entry| {
            allocator.free(entry.key);
            allocator.free(entry.value);
            if (entry.default_value) |val| {
                allocator.free(val);
            }
        }
        allocator.free(entries);
    }

    try std.testing.expectEqual(@as(usize, 1), entries.len);
    try std.testing.expectEqual(@as(usize, 1000), entries[0].value.len);
}

test "parseEnvFile - quotes in values" {
    const allocator = std.testing.allocator;

    const input =
        \\SINGLE='single quoted'
        \\DOUBLE="double quoted"
        \\MIXED='single "and" double'
    ;

    const entries = try parseEnvFile(allocator, input);
    defer {
        for (entries) |entry| {
            allocator.free(entry.key);
            allocator.free(entry.value);
            if (entry.default_value) |val| {
                allocator.free(val);
            }
        }
        allocator.free(entries);
    }

    try std.testing.expectEqual(@as(usize, 3), entries.len);
    // Note: We don't strip quotes - that's intentional
    try std.testing.expectEqualStrings("'single quoted'", entries[0].value);
    try std.testing.expectEqualStrings("\"double quoted\"", entries[1].value);
    try std.testing.expectEqualStrings("'single \"and\" double'", entries[2].value);
}

test "inferType - priority order" {
    // Boolean takes priority over string
    try std.testing.expectEqual(ConfigType.boolean, inferType("true"));

    // Connection string takes priority over URL
    try std.testing.expectEqual(ConfigType.connection_string, inferType("postgresql://localhost"));

    // URL takes priority over string
    try std.testing.expectEqual(ConfigType.url, inferType("https://example.com"));

    // JSON takes priority over string
    try std.testing.expectEqual(ConfigType.json, inferType("{\"test\":1}"));

    // Integer takes priority over string
    try std.testing.expectEqual(ConfigType.integer, inferType("42"));
}

test "inferType - ambiguous cases" {
    // postgres:// could be connection string but we don't support it
    try std.testing.expectEqual(ConfigType.string, inferType("postgres://localhost"));

    // Long URL is not a secret
    try std.testing.expectEqual(ConfigType.url, inferType("https://example.com/very/long/path/that/exceeds/20/characters"));

    // Number with decimal is not integer
    try std.testing.expectEqual(ConfigType.string, inferType("3.14"));

    // Large number
    try std.testing.expectEqual(ConfigType.integer, inferType("999999999"));

    // Negative number
    try std.testing.expectEqual(ConfigType.integer, inferType("-42"));
}

test "inferType - secret detection boundaries" {
    // Exactly 20 chars - still string
    try std.testing.expectEqual(ConfigType.string, inferType("12345678901234567890"));

    // 21 chars - becomes secret
    try std.testing.expectEqual(ConfigType.secret, inferType("123456789012345678901"));

    // Long but with spaces - not secret
    try std.testing.expectEqual(ConfigType.string, inferType("this is a very long string with spaces"));

    // Long with special chars - not secret
    try std.testing.expectEqual(ConfigType.string, inferType("long_string_with_underscores_21"));

    // Long alphanumeric with dash - is secret
    try std.testing.expectEqual(ConfigType.secret, inferType("secret-key-123456789"));
}

test "inferType - json edge cases" {
    // Empty object
    try std.testing.expectEqual(ConfigType.json, inferType("{}"));

    // Empty array
    try std.testing.expectEqual(ConfigType.json, inferType("[]"));

    // Just opening brace - still json (might be malformed)
    try std.testing.expectEqual(ConfigType.json, inferType("{"));

    // JSON-like but not starting with bracket
    try std.testing.expectEqual(ConfigType.string, inferType(" {\"key\":\"value\"}"));
}

test "inferType - connection string variants" {
    try std.testing.expectEqual(ConfigType.connection_string, inferType("postgresql://user:pass@localhost:5432/db"));
    try std.testing.expectEqual(ConfigType.connection_string, inferType("mysql://root@localhost/mydb"));
    try std.testing.expectEqual(ConfigType.connection_string, inferType("mongodb://localhost:27017/test"));
    try std.testing.expectEqual(ConfigType.connection_string, inferType("redis://localhost:6379/0"));

    // Not supported protocols
    try std.testing.expectEqual(ConfigType.string, inferType("sqlite://db.sqlite"));
    try std.testing.expectEqual(ConfigType.string, inferType("postgres://localhost")); // Different scheme
}

test "inferType - boolean case sensitivity" {
    try std.testing.expectEqual(ConfigType.boolean, inferType("true"));
    try std.testing.expectEqual(ConfigType.boolean, inferType("false"));

    // Case sensitive - these are strings
    try std.testing.expectEqual(ConfigType.string, inferType("True"));
    try std.testing.expectEqual(ConfigType.string, inferType("FALSE"));
    try std.testing.expectEqual(ConfigType.string, inferType("TRUE"));
    try std.testing.expectEqual(ConfigType.string, inferType("yes"));
    try std.testing.expectEqual(ConfigType.string, inferType("no"));
    try std.testing.expectEqual(ConfigType.string, inferType("1"));
    try std.testing.expectEqual(ConfigType.string, inferType("0"));
}

test "inferType - url edge cases" {
    try std.testing.expectEqual(ConfigType.url, inferType("http://localhost"));
    try std.testing.expectEqual(ConfigType.url, inferType("https://example.com:8080"));
    try std.testing.expectEqual(ConfigType.url, inferType("http://192.168.1.1"));
    try std.testing.expectEqual(ConfigType.url, inferType("https://example.com/path?query=value#fragment"));

    // Not HTTP/HTTPS
    try std.testing.expectEqual(ConfigType.string, inferType("ftp://example.com"));
    try std.testing.expectEqual(ConfigType.string, inferType("ws://example.com"));
}

test "ConfigType.fromString - all types" {
    try std.testing.expectEqual(ConfigType.string, ConfigType.fromString("string").?);
    try std.testing.expectEqual(ConfigType.secret, ConfigType.fromString("secret").?);
    try std.testing.expectEqual(ConfigType.integer, ConfigType.fromString("integer").?);
    try std.testing.expectEqual(ConfigType.boolean, ConfigType.fromString("boolean").?);
    try std.testing.expectEqual(ConfigType.url, ConfigType.fromString("url").?);
    try std.testing.expectEqual(ConfigType.connection_string, ConfigType.fromString("connection_string").?);
    try std.testing.expectEqual(ConfigType.json, ConfigType.fromString("json").?);

    // Invalid types
    try std.testing.expectEqual(@as(?ConfigType, null), ConfigType.fromString("invalid"));
    try std.testing.expectEqual(@as(?ConfigType, null), ConfigType.fromString(""));
    try std.testing.expectEqual(@as(?ConfigType, null), ConfigType.fromString("String")); // Case sensitive
}

test "checkFileExists and checkDirExists" {
    // Test with current file (should exist)
    try std.testing.expect(checkFileExists("build.zig"));

    // Test with non-existent file
    try std.testing.expect(!checkFileExists("nonexistent_file_that_doesnt_exist.txt"));

    // Test with directory that exists
    try std.testing.expect(checkDirExists("src"));

    // Test with non-existent directory
    try std.testing.expect(!checkDirExists("nonexistent_directory_12345"));
}

test "readFile helper" {
    const allocator = std.testing.allocator;

    // Create a temporary test file
    const test_content = "test content\nline 2\n";
    const test_file = try std.fs.cwd().createFile("test_readfile.tmp", .{});
    defer {
        test_file.close();
        std.fs.cwd().deleteFile("test_readfile.tmp") catch {};
    }

    try test_file.writeAll(test_content);
    test_file.close();

    // Read it back
    const content = try readFile(allocator, "test_readfile.tmp");
    defer allocator.free(content);

    try std.testing.expectEqualStrings(test_content, content);
}

test "generateSchemaYaml - basic" {
    const allocator = std.testing.allocator;

    // Create test directory
    std.fs.cwd().makeDir(".configflow_test") catch {};
    defer std.fs.cwd().deleteDir(".configflow_test") catch {};

    // Create test config entries
    var entries = [_]ConfigEntry{
        .{
            .key = try allocator.dupe(u8, "DATABASE_URL"),
            .config_type = .connection_string,
            .required = true,
            .description = try allocator.dupe(u8, "Database connection"),
        },
        .{
            .key = try allocator.dupe(u8, "DEBUG"),
            .config_type = .boolean,
            .required = false,
            .description = try allocator.dupe(u8, ""),
        },
    };
    defer for (entries) |entry| entry.deinit(allocator);

    // Generate schema in test directory
    const orig_dir = try std.fs.cwd().openDir(".", .{});
    defer orig_dir.close();

    var test_dir = try std.fs.cwd().openDir(".configflow_test", .{});
    defer test_dir.close();

    try test_dir.setAsCwd();
    defer orig_dir.setAsCwd() catch {};

    try std.fs.cwd().makeDir(".configflow") catch {};
    defer std.fs.cwd().deleteTree(".configflow") catch {};

    try generateSchemaYaml(allocator, &entries);

    // Verify file was created and contains expected content
    const content = try readFile(allocator, ".configflow/schema.yml");
    defer allocator.free(content);

    try std.testing.expect(std.mem.indexOf(u8, content, "DATABASE_URL:") != null);
    try std.testing.expect(std.mem.indexOf(u8, content, "type: connection_string") != null);
    try std.testing.expect(std.mem.indexOf(u8, content, "required: true") != null);
    try std.testing.expect(std.mem.indexOf(u8, content, "description: \"Database connection\"") != null);
    try std.testing.expect(std.mem.indexOf(u8, content, "DEBUG:") != null);
    try std.testing.expect(std.mem.indexOf(u8, content, "type: boolean") != null);
    try std.testing.expect(std.mem.indexOf(u8, content, "required: false") != null);
}

test "generateSchemaYaml - special characters in description" {
    const allocator = std.testing.allocator;

    std.fs.cwd().makeDir(".configflow_test2") catch {};
    defer std.fs.cwd().deleteDir(".configflow_test2") catch {};

    var entries = [_]ConfigEntry{
        .{
            .key = try allocator.dupe(u8, "KEY"),
            .config_type = .string,
            .required = true,
            .description = try allocator.dupe(u8, "Description with \"quotes\" and 'apostrophes'"),
        },
    };
    defer for (entries) |entry| entry.deinit(allocator);

    const orig_dir = try std.fs.cwd().openDir(".", .{});
    defer orig_dir.close();

    var test_dir = try std.fs.cwd().openDir(".configflow_test2", .{});
    defer test_dir.close();

    try test_dir.setAsCwd();
    defer orig_dir.setAsCwd() catch {};

    try std.fs.cwd().makeDir(".configflow") catch {};
    defer std.fs.cwd().deleteTree(".configflow") catch {};

    try generateSchemaYaml(allocator, &entries);

    const content = try readFile(allocator, ".configflow/schema.yml");
    defer allocator.free(content);

    try std.testing.expect(std.mem.indexOf(u8, content, "Description with \\\"quotes\\\" and 'apostrophes'") != null or
        std.mem.indexOf(u8, content, "Description with \"quotes\" and 'apostrophes'") != null);
}

test "generateConfigYaml - different formats" {
    const allocator = std.testing.allocator;

    std.fs.cwd().makeDir(".configflow_test3") catch {};
    defer std.fs.cwd().deleteDir(".configflow_test3") catch {};

    const orig_dir = try std.fs.cwd().openDir(".", .{});
    defer orig_dir.close();

    var test_dir = try std.fs.cwd().openDir(".configflow_test3", .{});
    defer test_dir.close();

    try test_dir.setAsCwd();
    defer orig_dir.setAsCwd() catch {};

    try std.fs.cwd().makeDir(".configflow") catch {};
    defer std.fs.cwd().deleteTree(".configflow") catch {};

    // Test env format
    try generateConfigYaml(allocator, "env", ".env");
    const content = try readFile(allocator, ".configflow/config.yml");
    defer allocator.free(content);

    try std.testing.expect(std.mem.indexOf(u8, content, "format: env") != null);
    try std.testing.expect(std.mem.indexOf(u8, content, "path: .env") != null);

    // Test yaml format
    try generateConfigYaml(allocator, "yaml", "config.yaml");
    const content2 = try readFile(allocator, ".configflow/config.yml");
    defer allocator.free(content2);

    try std.testing.expect(std.mem.indexOf(u8, content2, "format: yaml") != null);
    try std.testing.expect(std.mem.indexOf(u8, content2, "path: config.yaml") != null);

    // Test json format
    try generateConfigYaml(allocator, "json", "config.json");
    const content3 = try readFile(allocator, ".configflow/config.yml");
    defer allocator.free(content3);

    try std.testing.expect(std.mem.indexOf(u8, content3, "format: json") != null);
    try std.testing.expect(std.mem.indexOf(u8, content3, "path: config.json") != null);
}

test "ConfigEntry deinit" {
    const allocator = std.testing.allocator;

    const entry = ConfigEntry{
        .key = try allocator.dupe(u8, "TEST_KEY"),
        .config_type = .string,
        .required = true,
        .description = try allocator.dupe(u8, "Test description"),
    };

    // Should not leak memory
    entry.deinit(allocator);
}
